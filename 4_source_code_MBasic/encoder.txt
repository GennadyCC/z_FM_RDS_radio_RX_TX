'=============================================================================
'ОБРАБОТКА ЭНКОДЕРА
'=============================================================================
'поддерживаются команды
'init_encoder()        ' инициализация энкодера (прописываются порты и таймер 
'                       для энкодера. Средний провод подключается на минус)
'set_encoder(100, 50)  ' настройка энкодера 100 - максимальное 
'                        значение, 50 - значение с которого начинается счет.
'encod_ = encoder()     ' прочитать значение таймера (энкодера)
'=============================================================================

module encoder
sub procedure init_encoder()
sub procedure set_encoder(dim e_max, e_carrent as word) ' настроить энкодер
sub function encoder as word  ' получить данные энкодера
sub function button_ as byte
sub function check_over_plus (dim current, e_max as word ) as word     ' функция проверки переполнения энкодера
sub function check_over_minus (dim current, e_min as word ) as word     ' функция проверки переполнения энкодера
'sub function check_over_plus_float (dim current, e_max as float) as float     ' функция проверки переполнения энкодера
'sub function check_over_minus_float (dim current, e_min as float) as float     ' функция проверки переполнения энкодера

implements

sub function button_ as byte
  result = 0
  if (Button(GPIOA_IDR, 0, 1, 0) = 0) then
     inc(result)
     while Button(GPIOA_IDR, 0, 1, 0) = 0
        inc(result)
        delay_ms(10)
        if result = 150 then
          break
        end if
     wend
  end if

end sub

sub procedure init_encoder()
RCC_APB2ENR.B3 = 1  'тактирование порта B
RCC_APB2ENR.B2 = 1  'тактирование порта A
'GPIOB_CRL.B21 = 0   ' 00: Input mode для Port B5  'кнопка
'GPIOB_CRL.B20 = 0
GPIOA_CRL.B0 = 0   ' 00: Input mode для Port A0  'кнопка
GPIOA_CRL.B1 = 0
GPIOB_CRL.B25 = 0   ' 00: Input mode для Port B6
GPIOB_CRL.B24 = 0
GPIOB_CRL.B29 = 0   ' 00: Input mode для Port B7
GPIOB_CRL.B28 = 0
'GPIOB_CRL.B23 = 1   '10: Input with pull-up / pull-down для Port B5
'GPIOB_CRL.B22 = 0
GPIOA_CRL.B3 = 1   '10: Input with pull-up / pull-down для Port A0
GPIOA_CRL.B2 = 0
GPIOB_CRL.B27 = 1   '10: Input with pull-up / pull-down для Port B6
GPIOB_CRL.B26 = 0
GPIOB_CRL.B31 = 1   '10: Input with pull-up / pull-down для Port B7
GPIOB_CRL.B30 = 0

'GPIOB_BSRR.B5 = 1   'подтяжка к +   'кнопка
GPIOA_BSRR.B0 = 0   'подтяжка к -   'кнопка
GPIOB_BSRR.B6 = 1   'подтяжка к +
GPIOB_BSRR.B7 = 1   'подтяжка к +

RCC_APB1ENR.B2 = 1   'тактирование таймера 4
CC1S0_TIM4_CCMR1_Input_bit = 1 'полярность сигнала для каждого входа
CC1S1_TIM4_CCMR1_Input_bit = 0
CC2S0_TIM4_CCMR1_Input_bit = 1
CC2S1_TIM4_CCMR1_Input_bit = 0
CC1P_TIM4_CCER_bit = 1
CC2P_TIM4_CCER_bit = 1
SMS0_TIM4_SMCR_bit = 1  'включить режим Энкодера
SMS1_TIM4_SMCR_bit = 1
SMS2_TIM4_SMCR_bit = 0

end sub

sub procedure set_encoder(dim e_max, e_carrent as word)
e_max = e_max * 4
CEN_TIM4_CR1_bit = 0    'выключаем таймер
TIM4_ARR = e_max         'значение до которого считает таймер
TIM4_CNT = e_carrent * 4     ' начальное значение энкодера (максимальное значение таймера (TIM4_ARR)/4)
CEN_TIM4_CR1_bit = 1    'включаем таймер
end sub

sub function encoder as word     ' функция чтения энкодера
result = TIM4_CNT     ' прочитать значение таймера (энкодера)
result = result  / 4
end sub

sub function check_over_plus (dim current, e_max as word ) as word     ' функция проверки переполнения энкодера
  result = current
  if current >= e_max then
   result = e_max
   else
   result = result +1
  end if


end sub

sub function check_over_minus (dim current, e_min as word ) as word     ' функция проверки переполнения энкодера
  result = current
  if current <= e_min then
   result = e_min
   else
   result = result -1
  end if
end sub


end.